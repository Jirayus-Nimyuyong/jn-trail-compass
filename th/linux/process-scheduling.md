# การใช้ Process Scheduling ใน Linux

## บทนำ

ในระบบปฏิบัติการ Linux, **Process Scheduling** (การจัดกำหนดการทำงานของกระบวนการ) คือกระบวนการที่ระบบปฏิบัติการใช้เพื่อจัดสรรทรัพยากร CPU ให้กับกระบวนการต่างๆ ที่กำลังทำงานในระบบ การจัดกำหนดการนี้มีความสำคัญเพื่อให้กระบวนการต่างๆ ได้รับการดำเนินการอย่างเป็นระเบียบและมีประสิทธิภาพ

ในบทนี้, เราจะเรียนรู้เกี่ยวกับวิธีการทำงานของ **Process Scheduling**, การจัดการกระบวนการใน Linux, และคำสั่งที่ใช้ในการตรวจสอบและปรับแต่งการจัดกำหนดการ

## 1. Process Scheduling คืออะไร?

Process Scheduling คือการที่ CPU ถูกจัดสรรให้กับกระบวนการต่างๆ ที่รอการทำงาน กระบวนการทั้งหมดที่ทำงานในระบบจะถูกจัดใน **queue** และระบบจะเลือกกระบวนการที่ควรได้รับการดำเนินการในแต่ละช่วงเวลา โดยมีการใช้อัลกอริธึมต่างๆ ในการตัดสินใจว่ากระบวนการไหนควรจะทำงานในลำดับถัดไป

### 1.1 ประเภทของ Scheduling Algorithms
- **First-Come, First-Served (FCFS):** การจัดกำหนดการแบบ FIFO (First In, First Out) คือกระบวนการที่เข้าคิวก่อนจะได้รับการประมวลผลก่อน
- **Shortest Job Next (SJN):** ระบบเลือกกระบวนการที่มีการทำงานน้อยที่สุด
- **Round Robin (RR):** การจัดกำหนดการแบบหมุนเวียน โดยให้แต่ละกระบวนการมีเวลาทำงานเท่ากัน
- **Priority Scheduling:** กระบวนการจะถูกจัดตามลำดับความสำคัญ

## 2. การตรวจสอบกระบวนการใน Linux

### 2.1 การใช้คำสั่ง `ps`

คำสั่ง `ps` ใช้ในการดูสถานะของกระบวนการที่กำลังทำงานในระบบ

```bash
ps aux
```

- `a` แสดงกระบวนการของผู้ใช้ทั้งหมด
- `u` แสดงข้อมูลรายละเอียดของกระบวนการ
- `x` แสดงกระบวนการที่ไม่ใช่เทอร์มินัล

ตัวอย่างการใช้:

```bash
ps aux | grep process_name
```

คำสั่งนี้จะแสดงกระบวนการทั้งหมดที่เกี่ยวข้องกับ `process_name`

### 2.2 การใช้คำสั่ง `top`

คำสั่ง `top` แสดงรายการกระบวนการที่ใช้ทรัพยากรระบบมากที่สุด

```bash
top
```

- คำสั่งนี้จะแสดงกระบวนการทั้งหมดในระบบและสามารถดูข้อมูลต่างๆ เช่น CPU, RAM, และเวลาการทำงานของแต่ละกระบวนการ

### 2.3 การใช้คำสั่ง `htop`

คำสั่ง `htop` เป็นเครื่องมือที่แสดงกระบวนการในรูปแบบที่มีความเป็นกราฟิกมากขึ้น สามารถติดตั้งได้โดยใช้คำสั่ง:

```bash
sudo apt install htop
```

จากนั้นสามารถใช้คำสั่ง `htop` เพื่อดูสถานะของกระบวนการ

```bash
htop
```

## 3. การจัดลำดับความสำคัญของกระบวนการ

ใน Linux, กระบวนการแต่ละตัวมีลำดับความสำคัญที่เรียกว่า **nice value** ซึ่งจะบ่งชี้ว่ากระบวนการนั้นมีลำดับความสำคัญมากน้อยแค่ไหน

### 3.1 การตรวจสอบ Nice Value

คำสั่ง `ps` สามารถใช้เพื่อตรวจสอบค่า **nice value** ของกระบวนการ:

```bash
ps -eo pid,comm,ni
```

- `pid` คือรหัสกระบวนการ
- `comm` คือชื่อกระบวนการ
- `ni` คือค่า nice value ของกระบวนการ

### 3.2 การปรับแต่ง Nice Value

การใช้คำสั่ง `nice` และ `renice` ช่วยให้สามารถปรับแต่ง nice value ของกระบวนการได้

#### 3.2.1 การใช้คำสั่ง `nice`

คำสั่ง `nice` ใช้ในการเริ่มต้นกระบวนการใหม่โดยกำหนดค่า nice value:

```bash
nice -n 10 command
```

- `-n 10` คือการตั้งค่า nice value เป็น 10 (ค่าเริ่มต้นคือ 0)

#### 3.2.2 การใช้คำสั่ง `renice`

คำสั่ง `renice` ใช้ในการปรับค่า nice value ของกระบวนการที่กำลังทำงานอยู่:

```bash
renice -n 10 -p PID
```

- `-n 10` คือการตั้งค่า nice value ใหม่
- `-p PID` คือรหัสของกระบวนการที่ต้องการปรับ

## 4. การใช้ CPU Scheduling

### 4.1 การตั้งค่า Scheduling Policy

Linux รองรับหลายอัลกอริธึมในการจัดการ CPU scheduling และสามารถเลือกได้ตามความต้องการ เช่น:

- **SCHED_OTHER (default)**: ใช้สำหรับกระบวนการทั่วไป
- **SCHED_FIFO (First In First Out)**: ใช้สำหรับกระบวนการที่ต้องการประมวลผลตามลำดับที่มาถึง
- **SCHED_RR (Round Robin)**: ใช้สำหรับการหมุนเวียนกระบวนการ
- **SCHED_BATCH**: ใช้สำหรับงานที่ไม่จำเป็นต้องใช้งาน interactive

### 4.2 การใช้ `chrt`

คำสั่ง `chrt` ใช้ในการตั้งค่า policy และ priority ของกระบวนการที่กำลังทำงาน

```bash
chrt -f 10 PID
```

- `-f` กำหนดให้กระบวนการใช้ FIFO scheduling
- `10` คือ priority ของกระบวนการ

## 5. การควบคุม Process Scheduling โดยใช้ `systemd`

หากระบบ Linux ใช้ **systemd** ในการจัดการ services, สามารถใช้ `systemctl` ในการควบคุมการ scheduling ของบริการต่างๆ:

### 5.1 การตั้งค่าการ Scheduling ของ Service

การตั้งค่า `CPU Scheduling` ของบริการใน `systemd` สามารถทำได้โดยการแก้ไขไฟล์หน่วยบริการ เช่น:

```ini
[Service]
CPUQuota=50%
```

- `CPUQuota` ใช้เพื่อจำกัดการใช้ CPU ของบริการ

## 6. สรุป

การจัดการ **Process Scheduling** ใน Linux ช่วยให้กระบวนการต่างๆ ได้รับการจัดสรร CPU อย่างเหมาะสมและมีประสิทธิภาพ เครื่องมือเช่น `ps`, `top`, `nice`, `renice`, และ `chrt` ช่วยให้ผู้ดูแลระบบสามารถตรวจสอบและปรับแต่งการทำงานของกระบวนการในระบบได้อย่างยืดหยุ่น